<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aqueous - Bubble Synth</title>
    <style>
        @font-face {
            font-family: 'Sailing Scribble';
            src: url('sailing scribe font/SailingScribe-1jEYM.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(180deg, #001122 0%, #003366 50%, #004488 100%);
            font-family: Arial, sans-serif;
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        .water-surface {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #001133 0%, #001133 30%, #4da6ff 30%, #66b3ff 100%);
            overflow: hidden;
        }

        .surface-line {
            position: absolute;
            top: 30%;
            left: 0;
            width: 100%;
            height: 4px;
            background: transparent;
            overflow: hidden;
        }

        .surface-line::before {
            content: '';
            position: absolute;
            top: 8px;
            left: 0;
            width: 100%;
            height: 2px;
            border-top: 2px dotted rgba(0,200,255,0.4);
        }

        .wave-segment {
            position: absolute;
            width: 10%;
            height: 4px;
            background: #00ccff;
            border-radius: 2px;
        }

        .wave-segment:nth-child(1) { left: 0%; animation: wave 3s ease-in-out infinite 0s; }
        .wave-segment:nth-child(2) { left: 10%; animation: wave 3s ease-in-out infinite 0.3s; }
        .wave-segment:nth-child(3) { left: 20%; animation: wave 3s ease-in-out infinite 0.6s; }
        .wave-segment:nth-child(4) { left: 30%; animation: wave 3s ease-in-out infinite 0.9s; }
        .wave-segment:nth-child(5) { left: 40%; animation: wave 3s ease-in-out infinite 1.2s; }
        .wave-segment:nth-child(6) { left: 50%; animation: wave 3s ease-in-out infinite 1.5s; }
        .wave-segment:nth-child(7) { left: 60%; animation: wave 3s ease-in-out infinite 1.8s; }
        .wave-segment:nth-child(8) { left: 70%; animation: wave 3s ease-in-out infinite 2.1s; }
        .wave-segment:nth-child(9) { left: 80%; animation: wave 3s ease-in-out infinite 2.4s; }
        .wave-segment:nth-child(10) { left: 90%; animation: wave 3s ease-in-out infinite 2.7s; }

        @keyframes wave {
            0%, 100% { 
                transform: translateY(0px);
            }
            25% { 
                transform: translateY(-100px);
            }
            50% { 
                transform: translateY(0px);
            }
            75% { 
                transform: translateY(100px);
            }
        }

        .bubble {
            position: absolute;
            border-radius: 50%;
            background: #66ccff;
            border: 2px solid #00ccff;
            cursor: pointer;
            pointer-events: auto;
            z-index: 10;
        }

        .bubble:hover {
            background: #88ddff;
            border-color: #0099cc;
        }

        .bubble.popping {
            animation: surfacePop 0.8s ease-out forwards;
        }

        @keyframes surfacePop {
            0% { 
                transform: scale(1); 
                opacity: 1; 
            }
            30% { 
                transform: scale(1.8); 
                opacity: 0.9;
                background: #aaeeff;
            }
            100% { 
                transform: scale(3.5); 
                opacity: 0; 
            }
        }

        .controls-top {
            position: absolute;
            top: 30px;
            right: 30px;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 10;
        }

        .bubble-controls {
            position: absolute;
            top: 80px;
            right: 30px;
            display: none;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
            background: rgba(0,50,100,0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #00ccff;
        }

        .bubble-controls.active {
            display: flex;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
        }

        .control-label {
            min-width: 100px;
            color: #00ccff;
            font-family: Arial, sans-serif;
        }

        .control-slider {
            width: 120px;
            height: 4px;
            background: #004466;
            border-radius: 2px;
            outline: none;
            appearance: none;
            -webkit-appearance: none;
        }

        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #00ccff;
            border-radius: 50%;
            cursor: pointer;
        }

        .control-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #00ccff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .control-value {
            min-width: 30px;
            color: #88ddff;
            font-size: 11px;
        }

        .control-btn {
            background: #004466;
            border: 2px solid #00ccff;
            color: #00ccff;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: #006688;
            border-color: #00aadd;
        }

        .title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 64px;
            font-weight: normal;
            letter-spacing: 4px;
            color: #00ccff;
            z-index: 5;
            font-family: Arial, sans-serif;
        }

        .status {
            position: absolute;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 18px;
            opacity: 0.6;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
            font-family: 'Courier New', monospace;
            transition: opacity 0.5s ease;
            line-height: 1.4;
        }

        .status.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .frequency-labels {
            position: absolute;
            top: calc(30% - 25px);
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            color: rgba(255,255,255,0.7);
            font-size: 12px;
        }

        .debug-panel {
            position: absolute;
            top: 150px;
            right: 30px;
            background: rgba(0,30,60,0.9);
            border: 1px solid #00ccff;
            border-radius: 10px;
            padding: 15px;
            max-width: 300px;
            font-size: 11px;
            color: #88ddff;
            z-index: 20;
        }

        .debug-panel h4 {
            margin-top: 0;
            color: #00ccff;
        }

        .debug-info {
            margin: 5px 0;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="water-surface" id="waterSurface">
            <div class="frequency-labels">
                <span>200Hz</span>
                <span>5kHz</span>
            </div>
            <div class="surface-line">
                <div class="wave-segment"></div>
                <div class="wave-segment"></div>
                <div class="wave-segment"></div>
                <div class="wave-segment"></div>
                <div class="wave-segment"></div>
                <div class="wave-segment"></div>
                <div class="wave-segment"></div>
                <div class="wave-segment"></div>
                <div class="wave-segment"></div>
                <div class="wave-segment"></div>
            </div>
        </div>
        
        <div class="title">AQUEOUS</div>
        
        <div class="controls-top">
            <div class="control-group" style="margin-right: 15px;">
                <select id="midiOutputSelect" class="control-btn" style="min-width: 180px;">
                    <option value="">-- Select MIDI Output --</option>
                </select>
            </div>
            <button class="control-btn" id="startBubbles">Start</button>
            <button class="control-btn" id="stopBubbles">Stop</button>
            <button class="control-btn" id="refreshMIDI">Refresh MIDI</button>
        </div>
        
        <div class="debug-panel" id="debugPanel">
            <h4>MIDI Debug Info</h4>
            <div class="debug-info" id="debugInfo">Initializing...</div>
        </div>
        
        <div class="bubble-controls" id="bubbleControls">
            <div class="control-group">
                <label class="control-label">Bubble Speed:</label>
                <input class="control-slider" id="bubbleSpeed" type="range" min="0.5" max="2.5" value="1.5" step="0.1">
                <span class="control-value" id="bubbleSpeedValue">1.5</span>
            </div>
            <div class="control-group">
                <label class="control-label">Bubble Size:</label>
                <input class="control-slider" id="bubbleSize" type="range" min="10" max="40" value="25" step="1">
                <span class="control-value" id="bubbleSizeValue">25</span>
            </div>
            <div class="control-group">
                <label class="control-label">Bubble Density:</label>
                <input class="control-slider" id="bubbleDensity" type="range" min="0.5" max="2.5" value="1.2" step="0.1">
                <span class="control-value" id="bubbleDensityValue">1.2</span>
            </div>
            <div class="control-group">
                <label class="control-label">Split Chance:</label>
                <input class="control-slider" id="bubbleSplit" type="range" min="0" max="0.5" value="0.1" step="0.05">
                <span class="control-value" id="bubbleSplitValue">0.1</span>
            </div>
        </div>
        
        <div class="status" id="status">Press Start to Begin<br>Bubbles trigger sound when they pop and hit the surface</div>
    </div>

    <script>
        // Global variables
        let audioContext;
        let oscillator;
        let isPlaying = false;
        let animationFrame;
        let bubbleGenerationActive = true;
        let bubbles = [];
        let isInitialized = false;
        let selectedMIDIOutput = null;
        let midiAccess = null;
        
        // Settings
        let settings = {
            bubbleSpeed: 1.5,
            bubbleSize: 25,
            bubbleDensity: 1.2,
            bubbleSplit: 0.1,
            bubbleLife: 5000,
            delayTime: 0.5,
            feedback: 0.4
        };
        
        // Tide state
        let isTideLeft = true;
        let lastTideChange = Date.now();

        // Debug logging function
        function debugLog(message) {
            console.log('[MIDI Debug]:', message);
            const debugInfo = document.getElementById('debugInfo');
            if (debugInfo) {
                debugInfo.innerHTML += '<br>' + message;
                debugInfo.scrollTop = debugInfo.scrollHeight;
            }
        }

        // Show status message
        function showStatus(message, duration = 3000) {
            const status = document.getElementById('status');
            status.innerHTML = message;
            status.classList.remove('hidden');
            if (duration > 0) {
                setTimeout(() => {
                    status.classList.add('hidden');
                }, duration);
            }
        }

        // Initialize Web MIDI API with better error handling
        async function initMIDI() {
            debugLog('Checking MIDI support...');
            
            try {
                if (!navigator.requestMIDIAccess) {
                    debugLog('❌ Web MIDI API not supported in this browser');
                    showStatus('Web MIDI is not supported in your browser', 0);
                    return false;
                }
                
                debugLog('✅ Web MIDI API supported, requesting access...');
                
                // Request MIDI access with sysex: true for better compatibility
                midiAccess = await navigator.requestMIDIAccess({ sysex: false });
                
                debugLog('✅ MIDI access granted');
                debugLog(`Inputs found: ${midiAccess.inputs.size}`);
                debugLog(`Outputs found: ${midiAccess.outputs.size}`);
                
                // List all available inputs and outputs for debugging
                debugLog('--- Available MIDI Inputs ---');
                midiAccess.inputs.forEach((input, key) => {
                    debugLog(`Input: ${input.name} (${input.id}) - ${input.state}`);
                });
                
                debugLog('--- Available MIDI Outputs ---');
                midiAccess.outputs.forEach((output, key) => {
                    debugLog(`Output: ${output.name} (${output.id}) - ${output.state}`);
                });
                
                updateMIDIPortList();
                
                // Listen for MIDI device changes
                midiAccess.onstatechange = (event) => {
                    debugLog(`MIDI device state changed: ${event.port.name} - ${event.port.state}`);
                    updateMIDIPortList();
                };
                
                return true;
            } catch (error) {
                debugLog('❌ Error initializing MIDI: ' + error.message);
                console.error('Error initializing MIDI:', error);
                showStatus('Error initializing MIDI: ' + error.message, 0);
                return false;
            }
        }
        
        // Update the MIDI port dropdown with better debugging
        function updateMIDIPortList() {
            const select = document.getElementById('midiOutputSelect');
            if (!select) {
                debugLog('❌ MIDI select element not found');
                return;
            }
            
            debugLog('Updating MIDI port list...');
            
            // Save current selection
            const currentId = select.value;
            
            // Clear existing options
            select.innerHTML = '<option value="">-- Select MIDI Output --</option>';
            
            if (!midiAccess) {
                debugLog('❌ No MIDI access available');
                return;
            }
            
            // Add available outputs
            const outputs = Array.from(midiAccess.outputs.values());
            debugLog(`Found ${outputs.length} MIDI outputs`);
            
            let foundPrevious = false;
            let addedCount = 0;
            
            outputs.forEach(output => {
                debugLog(`Adding output: ${output.name} (${output.id}) - state: ${output.state}`);
                
                // Only add connected outputs
                if (output.state === 'connected') {
                    const option = document.createElement('option');
                    option.value = output.id;
                    option.textContent = output.name || output.id;
                    select.appendChild(option);
                    addedCount++;
                    
                    if (output.id === currentId) {
                        option.selected = true;
                        foundPrevious = true;
                        selectedMIDIOutput = output;
                    }
                }
            });
            
            debugLog(`Added ${addedCount} connected MIDI outputs to dropdown`);
            
            // If previous selection is no longer available, clear it
            if (currentId && !foundPrevious) {
                selectedMIDIOutput = null;
                debugLog('Previous MIDI selection no longer available');
            }
        }
        
        // Handle MIDI output selection
        function onMIDIOutputChange(event) {
            const select = event.target;
            const selectedId = select.value;
            
            debugLog(`MIDI output selection changed to: ${selectedId}`);
            
            if (!selectedId) {
                selectedMIDIOutput = null;
                debugLog('MIDI output cleared');
                return;
            }
            
            const output = midiAccess.outputs.get(selectedId);
            if (output) {
                selectedMIDIOutput = output;
                debugLog(`✅ MIDI output selected: ${output.name || output.id}`);
                showStatus(`MIDI output: ${output.name || output.id}`, 2000);
            } else {
                debugLog('❌ Selected MIDI output not found');
            }
        }
        
        // Send MIDI note with debugging
        function sendMIDINote(note, velocity, duration = 300) {
            if (!selectedMIDIOutput) {
                debugLog('❌ No MIDI output selected');
                return;
            }
            
            debugLog(`Sending MIDI note: ${note}, velocity: ${velocity}, duration: ${duration}ms`);
            
            try {
                // Note on (0x90 = note on, channel 1)
                selectedMIDIOutput.send([0x90, note, velocity]);
                debugLog(`✅ MIDI note on sent: ${note}`);
                
                // Note off after duration
                setTimeout(() => {
                    if (selectedMIDIOutput) {
                        selectedMIDIOutput.send([0x80, note, 0]);
                        debugLog(`✅ MIDI note off sent: ${note}`);
                    }
                }, duration);
            } catch (error) {
                debugLog(`❌ Error sending MIDI note: ${error.message}`);
            }
        }
        
        // Manual refresh function
        function refreshMIDI() {
            debugLog('=== Manual MIDI Refresh ===');
            initMIDI();
        }
        
        // Initialize Web Audio API
        async function initAudio() {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Resume audio context on user interaction
                    document.addEventListener('click', async () => {
                        if (audioContext.state === 'suspended') {
                            await audioContext.resume();
                        }
                    }, { once: true });
                    
                    isInitialized = true;
                }
                return true;
            } catch (error) {
                console.error('Error initializing audio:', error);
                return false;
            }
        }

        // Start bubble generation
        async function startBubbles() {
            if (!isPlaying) {
                if (!isInitialized) {
                    // Initialize everything
                    async function init() {
                        // Initialize MIDI first
                        await initMIDI();
                        
                        // Initialize audio
                        const audioReady = await initAudio();
                        if (!audioReady) {
                            showStatus('Error initializing audio', 0);
                            return;
                        }
                        
                        // Set up UI
                        document.getElementById('bubbleControls').classList.add('active');
                        
                        // Add MIDI output change listener if the element exists
                        const midiSelect = document.getElementById('midiOutputSelect');
                        if (midiSelect) {
                            midiSelect.addEventListener('change', onMIDIOutputChange);
                        }
                        
                        // Start animation
                        animate();
                        showStatus('Click to create bubbles', 2000);
                    }
                    await init();
                }
                isPlaying = true;
                document.getElementById('status').classList.add('hidden');
            }
        }

        // Stop bubble generation and clear all bubbles
        function stopBubbles() {
            if (isPlaying) {
                cancelAnimationFrame(animationFrame);
                isPlaying = false;
            }
            
            // Clear all bubbles from the array and DOM
            bubbles.forEach(bubble => {
                if (bubble.element && bubble.element.parentNode) {
                    bubble.element.remove();
                }
            });
            bubbles = [];
            document.getElementById('bubbleControls').classList.remove('active');
            document.getElementById('status').classList.remove('hidden');
        }

        // Create bubble at position
        function createBubble(x, y, size = null) {
            const waterSurface = document.getElementById('waterSurface');
            const bubble = document.createElement('div');
            bubble.className = 'bubble';
            
            const bubbleSize = size || settings.bubbleSize + (Math.random() * 10 - 5);
            bubble.style.width = bubbleSize + 'px';
            bubble.style.height = bubbleSize + 'px';
            bubble.style.left = x + 'px';
            bubble.style.top = y + 'px';
            
            bubble.addEventListener('click', () => popBubble(bubble));
            
            waterSurface.appendChild(bubble);
            bubbles.push({
                element: bubble,
                x: x,
                y: y,
                size: bubbleSize,
                speed: 0.5 + Math.random() * 0.5,
                created: Date.now()
            });
        }

        // Pop bubble and trigger audio
        function popBubble(bubbleElement) {
            // Find bubble data
            const bubbleData = bubbles.find(b => b.element === bubbleElement);
            if (!bubbleData) return;
            
            // Play sound based on x position (frequency) and size (volume)
            const rect = document.getElementById('waterSurface').getBoundingClientRect();
            const x = bubbleData.x;
            const width = rect.width;
            const volume = bubbleData.size / 40; // Normalize size to 0-1 range
            
            playTone(x, width, volume);
            
            // Send MIDI note if output is selected
            if (selectedMIDIOutput) {
                // Map x position to note number (24-96, which is C1-C7)
                const note = Math.round(24 + ((x / width) * 72));
                // Map size to velocity (0-127)
                const velocity = Math.min(127, Math.round(bubbleData.size * 3));
                sendMIDINote(note, velocity, 300);
            }
            
            // Visual effect
            bubbleElement.classList.add('popping');
            
            // Remove bubble from array and DOM after animation
            setTimeout(() => {
                if (bubbleElement.parentNode) {
                    bubbleElement.parentNode.removeChild(bubbleElement);
                }
                // Remove from bubbles array
                const index = bubbles.findIndex(b => b.element === bubbleElement);
                if (index > -1) {
                    bubbles.splice(index, 1);
                }
            }, 800);
        }

        // Update bubble positions
        function updateBubbles() {
            bubbles.forEach(bubbleData => {
                bubbleData.y -= bubbleData.speed * settings.bubbleSpeed;
                bubbleData.element.style.top = bubbleData.y + 'px';
                
                // Check if bubble reached surface (30% from top)
                const surfaceY = window.innerHeight * 0.3;
                if (bubbleData.y <= surfaceY) {
                    popBubble(bubbleData.element);
                }
                
                // Remove old bubbles
                if (Date.now() - bubbleData.created > settings.bubbleLife) {
                    if (bubbleData.element.parentNode) {
                        bubbleData.element.parentNode.removeChild(bubbleData.element);
                    }
                }
            });
            
            // Clean up removed bubbles
            bubbles = bubbles.filter(bubbleData => 
                bubbleData.element.parentNode && 
                Date.now() - bubbleData.created <= settings.bubbleLife
            );
        }

        // Generate random bubbles
        function generateBubbles() {
            if (!isPlaying || !bubbleGenerationActive) return;
            
            const chance = 0.02 * settings.bubbleDensity;
            if (Math.random() < chance) {
                const waterSurface = document.getElementById('waterSurface');
                const x = Math.random() * waterSurface.offsetWidth;
                const y = waterSurface.offsetHeight * 0.9;
                createBubble(x, y);
            }
        }

        // Play a sine tone when bubble pops
        async function playTone(x, width, volume = 0.3) {
            try {
                if (!audioContext) {
                    const success = await initAudio();
                    if (!success) return;
                }
                
                // Ensure audio context is running
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                
                // Calculate frequency based on x position (200Hz to 5000Hz) using logarithmic scale
                const minFreq = 200;
                const maxFreq = 5000;
                const position = x / width; // 0 to 1
                const frequency = minFreq * Math.pow(maxFreq / minFreq, position);
                
                // Create oscillator and gain node
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                // Configure oscillator
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                
                // Configure gain envelope with volume control
                gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                
                // Connect nodes
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Start and stop
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.5);
                
            } catch (error) {
                console.error('Error playing tone:', error);
            }
        }

        // Main animation loop
        function animate() {
            updateBubbles();
            generateBubbles();
            animationFrame = requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('waterSurface').addEventListener('click', (e) => {
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Only create bubble if click is within water surface
            if (y > rect.height * 0.3) {
                createBubble(x, y);
                // Play tone at click position
                playTone(x, rect.width);
            }
        });
        
        // Button event listeners
        document.getElementById('startBubbles').addEventListener('click', startBubbles);
        document.getElementById('stopBubbles').addEventListener('click', stopBubbles);
        document.getElementById('refreshMIDI').addEventListener('click', refreshMIDI);
        
        // Initialize everything
        async function init() {
            debugLog('=== Initializing Aqueous ===');
            
            // Initialize MIDI immediately
            await initMIDI();
            
            // Initialize audio on first user interaction
            document.addEventListener('click', async () => {
                if (!isInitialized) {
                    await initAudio();
                }
            }, { once: true });
            
            animate();
            
            debugLog('✅ Aqueous initialized');
        }

        // Start when page loads
        document.addEventListener('DOMContentLoaded', init);
        
        // Bubble controls
        document.getElementById('bubbleSpeed').addEventListener('input', (e) => {
            settings.bubbleSpeed = parseFloat(e.target.value);
            document.getElementById('bubbleSpeedValue').innerText = settings.bubbleSpeed.toFixed(1);
        });
        
        document.getElementById('bubbleSize').addEventListener('input', (e) => {
            settings.bubbleSize = parseInt(e.target.value);
            document.getElementById('bubbleSizeValue').innerText = settings.bubbleSize;
        });
        
        document.getElementById('bubbleDensity').addEventListener('input', (e) => {
            settings.bubbleDensity = parseFloat(e.target.value);
            document.getElementById('bubbleDensityValue').innerText = settings.bubbleDensity.toFixed(1);
        });
        
        document.getElementById('bubbleSplit').addEventListener('input', (e) => {
            settings.bubbleSplit = parseFloat(e.target.value);
            document.getElementById('bubbleSplitValue').innerText = settings.bubbleSplit.toFixed(2);
        });
    </script>
</body>
</html>